"use client";
import React, { ChangeEvent, useEffect, useRef, useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import ToggleButton from "@/components/ui/toggle-button";
import "@/app/main/persona-selection-scrollbar.css";
// import Logo from "@/components/component/logo";
// import HeaderAvatar from "@/components/component/header-avatar";
import SideBar from "@/app/main/side-bar";
import PersonaChatHistory from "@/app/chat/persona-chat-history";
import { Message, useChat } from "ai/react";
import PersonaCard from "./persona-card";
import { formatTextToHTML } from "@/lib/textToHTML";
import Image from "next/image";
import { SessionProvider, useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { generateDALLE } from "@/lib/api/dall-e-operations";
import {
  fetchChatbot,
  fetchSaveConvo,
  fetchOldChat,
  fetchChatUID,
  fetchPromptSuggestion,
} from "@/lib/db/fetch-queries";
import { handleChatRegenerate } from "@/lib/chat/handle-chat-submit";
import UploadFilesDropdown from "./file-upload-component";
import UploadedFiles from "./uploaded-files";
import FileUploadComponent from "./file-upload-component";
import { PutBlobResult } from "@vercel/blob";
import { upload } from "@vercel/blob/client";
import { usePromptSuggestions } from "@/lib/functions/timer/prompt-suggestion-timer";
import AgentChatLoading from "./agent-chat-loading";
import Typewriter from "typewriter-effect";

import { Inter } from "next/font/google";
import DOMPurify from 'dompurify';


const inter = Inter({ subsets: ["latin"] });

interface AirisChatProps {
  historyConversationId?: string;
}

/**
 * Represents the Chat component.
 * @param {Object} params - The id object, telling which persona will be utilized.
 * @returns {JSX.Element} The Chat component.
 */
export function AirisChat({
  historyConversationId,
}: AirisChatProps): JSX.Element {


  const [mobileIsOpenHistory, setMobileIsOpenHistory] = useState(false);


  const endOfMessagesRef = useRef<HTMLDivElement>(null);

  const router = useRouter(); // Router
  
  const { data: session, status } = useSession(); // Access user information from session
  const user = session?.user;
  /**
   * Represents a useChat hook from ai-sdk
   * - the main backbone for streaming text like ChatGPT
   * @messages    - holds the chat messages, with three roles 'system', 'assistant', and 'user'
   * @setMessages - allows to manually update messages state (important on DALL-E and re-generate previous prompt)
   * @input       - holds the current input value in the chat component
   * @stop        - it stops the chat component from further generating a text. Only works on the general streaming the text, not on DALL-E and re-generating previous prompt
   * @isLoading   - contains the loading state of the chat component, is a boolean
   * @handleInputChange - handles the change event of the input field
   * @handleSubmit      - handles submission event of the chat component (GPT-4o only)
   */
  const {
    messages,
    setMessages,
    input,
    isLoading,
    handleInputChange,
    handleSubmit,
  } = useChat();

  /**
   * chatbot_id:
   * created_at:
   * persona_id:
   * role:
   * subpersona:
   * task:
   * sysprompt:
   * Only sysprompt is mostly used in the chatbot page, others will be used on selection page
   */
  const [chosenChatbot, setChosenChatbot] = useState<any>(null);

  const { promptSuggestions, handleTimeout } = usePromptSuggestions(); // Custom Hook on DALL-E-3 suggested words
  const [conversationId, setConversationId] = useState(0); // consists of the chatbot conversation_id from Database, default 0 == new chat
  const [refreshHistory, setRefreshHistory] = useState<boolean>(false); // becoming true allows chat history to be updated after the new chat has been saved
  const [isLoading2, setIsLoading2] = useState(false); // When isLoading2 is true, it indicates that the DALL-E API call or GPT-4o re-generate call is currently loading.
  const [placeholder, setPlaceholder] = useState("Type your message..."); // The placeholder text is displayed when the input field is empty.
  // Attributes of images to be generated by DALL-E
  const [quality, setQuality] = useState("standard");
  const [imgSize, setImgSize] = useState("256x256");
  const [imgStyle, setImgStyle] = useState("natural");
  const [quantity, setQuantity] = useState(1);
  const [model, setModel] = useState("gpt-4o-mini"); // The model can be either 'gpt-4o-mini' (default) or 'dall-e-2'.
  // Variables for just tracking the Rendering of the Page
  const mounted = useRef(true);
  const isFirstRender = useRef(true);
  const isSecondRender = useRef(true);
  const isPromptRendered = useRef(true);
  const [chatbotId, setChatbotId] = useState<string | null>(null); // chatbot ID stored when user clicks a prompt on selection page
  // Variables with their information from Session Storage (if new chat) or from Chat History
  const [aiName, setAiName] = useState<string | null>(null);
  const [aiTask, setAiTask] = useState<string | null>(null);
  const [aiLogo, setLogo] = useState<string | null>(null);

  useEffect(() => {
    // Scroll to the bottom whenever new content is added

    endOfMessagesRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);
  /**
   * UseEffect For setting some attribute to its corresponding default value depending on the model used for generating image
   */
  useEffect(() => {
    if (model == "dall-e-2") {
      setImgSize("256x256");
      setQuality("standard");
      setImgStyle("natural");
    } else if (model == "dall-e-3") {
      setImgSize("1024x1024");
    }
    console.log("MODEL has been updated to: " + model);
  }, [model]);
  /**
   * UseEffect For checking if system generates a new chat or calls a user's past chat conversation
   */
  useEffect(() => {
    if (historyConversationId) {
      /**
       * historyConversationId contains the URL Parameters /chat/[conversationid]
       * - Holds the ID of the chat history to be fetched and displayed.
       * - Validation Steps:
       *    1. [conversationid] should be a valid number.
       *    2. The user should be logged in (authenticated).
       *    3. The user should have access to the conversation being fetched (i.e., the right account).
       *    4. [conversationid] should exist and be valid in the database.
       */
      const numberHistoryConversationId = Number(historyConversationId); // Convert conversation ID from URL to a number

      const handleInvalidState = () => {
        router.push("/persona");
        return;
      };

      // 1.
      if (isNaN(numberHistoryConversationId)) {
        handleInvalidState();
      }

      // 2.
      if (status === "unauthenticated") {
        handleInvalidState();
      }

      if (status === "authenticated" && user != undefined) {
        /**
         * Validate the user access and fetch the relevant conversation data
         *  - Get the user_id for confirmation.
         *  - Get the previous chat conversation and set it to their respective states:
         *    - setConversationId: Sets the conversation ID state with the validated conversation ID.
         *    - setChosenChatbot: Updates the state with the chatbot details associated with the conversation.
         *    - setLogo: Sets the logo URL for the persona in the state and session storage.  - to be stored in SessionStorate
         *    - setAiName: Sets the AI's name in the state.                                   - to be stored in SessionStorate
         *    - setAiTask: Updates the state with the task or role of the chatbot.            - to be stored in SessionStorate
         *    - setMessages: Sets the previous conversation messages in the state. To be displayed on main chat interface
         */
        const validateUser = async () => {
          const data = await fetchChatUID(
            numberHistoryConversationId,
            user?.email
          );

          // 3.
          if (data == "wrong uid") {
            handleInvalidState();
          }

          setConversationId(numberHistoryConversationId);

          const getOldChat = async () => {
            try {
              const data = await fetchOldChat(numberHistoryConversationId);

              // 4.
              if (data.error != "") {
                handleInvalidState();
              }

              const chatdata = await fetchChatbot(data.chatbot_id);

              // Get the Persona Icons from the Blob Storage in Vercel, and compare each images to current Persona's logo_name
              const personalogo = await fetch("/api/image/image-persona-logo", {
                method: "POST",
                cache: "no-cache",
              });
              const response = await personalogo.json();
              response.blob.forEach((blob: any) => {
                const filename = blob.pathname.replace(
                  "Assets/persona_icons/",
                  ""
                );
                if (filename === data.result.logo_name) {
                  setLogo(blob.url);
                  localStorage.setItem("persona_logo", blob.url);
                }
              });

              // Store the necessary strings in localStorage
              localStorage.setItem("aiName", data.result.name ?? "");
              localStorage.setItem(
                "aiDescription",
                data.result.tagline ?? ""
              );
              localStorage.setItem(
                "chatbot_id",
                chatdata.chatbot.chatbot_id ?? ""
              );
              setChosenChatbot(chatdata.chatbot);
              setAiName(data.result.name);
              setAiTask(chatdata.chatbot.task);
              setMessages(data.messages);
            } catch (error) {
              console.error("Failed to fetch chatbot data", error);
            }
          };
          getOldChat();

          isPromptRendered.current = false; // Allow the system to save the conversation after the user has  sent a message
        };
        validateUser();
      }
    } else {
      /**
       * no historyConversationId means the chat is new
       * - information regarding chatbot_id and others (task, persona_logo, etc.) will be accessed on localStorage
       */

      // Assign the session variables into its respective states
      const chatbot_id = localStorage.getItem("chatbot_id");
      const logo = localStorage.getItem("persona_logo");
      const ai_name = localStorage.getItem("aiName");

      setChatbotId(chatbot_id);
      setLogo(logo);
      setAiName(ai_name);

      if (!mounted.current) return; // Prevent further actions if the component is not mounted

      if (chatbot_id && !historyConversationId) {
        // Function to fetch chatbot data based on chatbot_id
        const fetchData = async (chatbot_id: string | null) => {
          try {
            const data = await fetchChatbot(chatbot_id);
            const stringify = JSON.stringify(data.chatbot?.sysprompt);

            // Set the remaining variables respectively
            localStorage.setItem("task", data.chatbot.task);
            setChosenChatbot(data.chatbot);
            setAiTask(data.chatbot.task);

            /**
             * Add the System Prompt into the messages (but will not be shown in chat interface)
             *  and immediately submit it (by calling promptSubmit) to GPT api
             */
            setMessages([
              {
                id: "firstprompt",
                role: "user",
                content: stringify,
              },
            ]);
            promptSubmit({
              preventDefault: () => {},
              target: undefined,
            });
          } catch (error) {
            console.error("Failed to fetch chatbot data", error);
          }
        };
        fetchData(chatbot_id);
        return () => {
          mounted.current = false;
        };
      }
    }
  }, [historyConversationId, status]);
  /**
   * UseEffect For saving the conversation
   */
  useEffect(() => {
    // Skip the first and second render, avoid saving the conversation immediately
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    } else if (isSecondRender.current) {
      isSecondRender.current = false;
      return;
    }

    if (!isLoading && !isLoading2 && status == "authenticated" && user) {
      // Skip saving if the first prompt (systemprompt) is being set
      if (isPromptRendered.current) {
        isPromptRendered.current = false;
        return;
      }
      /**
       * Only save the data after the generation of GPT's response has stopped
       *  - setConversationId into the new conversation id if new chat has been saved
       *  - setRefreshHistory into true lets the chat history be updated
       */
      const saveData = async () => {
        const data = await fetchSaveConvo(
          messages,
          user?.email,
          chosenChatbot.chatbot_id,
          conversationId
        );
        console.log("NEW CONVO", data);
        if (data.new_convo) {
          setConversationId(data.convo_id);
          setRefreshHistory(true);
        }
      };

      saveData();
    }
  }, [isLoading, isLoading2]);

  /**
   * Handles the submission event of both chat components (GPT or DALL-E)
   * this is called by the form
   */

  async function promptSubmit(e: { target: any; preventDefault: () => void }) {
    e.preventDefault();
    // let newBlob = {'url': ""};
    if (model == "gpt-4o-mini") {
      const filesToHandle = imgFiles;
      setImgFiles([]);
      const submitImages64 = images64.map((image) =>
        typeof image === "string" ? image : ""
      );
      setImages64([]);

      console.log("IMAGE FILES LENGTH: ", filesToHandle.length);

      console.log("DISPLAY IMAGES: ", displayImages);

      let messagesToSet = [...messages];

      if (filesToHandle.length != 0) {
        for (let i = 0; i < displayImages[imgIdx].length; i++) {
          messagesToSet.push({
            id: "",
            role: "user",
            content: displayImages[imgIdx][i],
            annotations: imgFileNames[i],
          });
        }
        setMessages(messagesToSet);
      }
      setImgIdx((num) => num + 2);
      setImageFileNames([]);
      handleSubmit(e, {
        data: { images64: submitImages64, textInput: input },
      });

      if (filesToHandle == null) {
        console.log("No file selected");
      } else {
        console.log("FILE:");
        console.log(filesToHandle);

        for (const imgFile of filesToHandle) {
          if (imgFile) {
            const newBlob = await upload(imgFile.name, imgFile, {
              access: "public",
              handleUploadUrl: "/api/avatar/upload",
            });

            setDownloadUrls((prevState) => ({
              ...prevState,
              [imgIdx]: [...(prevState[imgIdx] || []), newBlob.downloadUrl],
            }));
          }
        }
      }
    } else {
      /**
       * DALL-E MODEL
       * Calls the app/api/image/route.ts to generate image output
       * set isLoading2 to true to disable the form while we wait for DALL-E to finish processing
       * then, manually add the user prompt to messages state, since this is not part of useChat hook
       * fetch DALL-E image url response and manually add it to messages state to display the output on to the UI
       */
      setIsLoading2(true);
      setMessages([
        ...messages,
        {
          id: "",
          role: "user",
          content: input,
        },
        {
          id: "",
          role: "assistant",
          content: "",
        },
      ]);

      generateDALLE(model, input, quality, imgSize, imgStyle, quantity).then(
        (res) => {
          setIsLoading2(false);
          console.log("CONTENT OF IMAGE GENERATION: ");
          console.log(res.response);
          console.log("FILE NAMES TO BE SET:");
          console.log(res.filenames);

          // Response of the GPT
          let messagesToShow: Message[] = [
            {
              id: "",
              role: "user",
              content: input,
            },
          ];
          for (let i = 0; i < res.response.length; i++) {
            messagesToShow.push({
              id: "",
              role: "assistant",
              content: res.response[i],
              data: res.downloadUrls[i],
              annotations: res.filenames[i],
              // Assuming res.filenames is an array with the same length as res.response
            });
          }
          setMessages([...messages, ...messagesToShow]);
        }
      );
    }
  }
  /**
   * Handles the change of the model and updates the placeholder text when toggle button is clicked.
   */
  function handleModelChange() {
    setQuality("standard");
    setImgSize("256x256");
    setImgStyle("natural");
    setQuantity(1);

    if (model == "gpt-4o-mini") {
      setModel("dall-e-2");

      setPlaceholder("Generate an image...");
    } else {
      setModel("gpt-4o-mini");
      console.log("MODEL SET TO: " + model);
      setPlaceholder("Type your message...");
    }

    setIsImageModel((i) => !i);
  }

  const [hoveredMessageIndex, setHoveredMessageIndex] = React.useState<
    number | null
  >(null); // Tracks the index of the message that is currently being hovered over in the UI.
  const [isHistoryOpen, setIsHistoryOpen] = React.useState<boolean>(true); // Controls the visibility of the chat history panel in the UI.
  const [isImageModel, setIsImageModel] = React.useState<boolean>(false); // Tracks whether the current model being used in the app is DALL-E Generation.
  const [imgFiles, setImgFiles] = useState<File[]>([]); // Stores an array of File objects representing the images selected by the user.
  const [images64, setImages64] = useState<(string | ArrayBuffer | null)[]>([]); // Stores the Base64 encoded strings of images that are selected for display or processing.
  const [downloadUrls, setDownloadUrls] = useState<{ [key: string]: string[] }>(
    {}
  ); // Maintains URLs generated for downloading images, organized by a unique key for each set of images.
  const [displayImages, setDisplayImages] = useState<{
    [key: number]: string[];
  }>({}); // Manages the display URLs for the images that are currently visible to the user in the UI.
  const [imgFileNames, setImageFileNames] = useState<
    (any)[]
  >([]); // Keeps track of the file names of the images selected, which can be used for annotations or references.
  const [imgIdx, setImgIdx] = useState(0); // Index for managing the current set of images being handled, useful for categorization or segmented display.
  //useEffect(() => {
  //  console.log("FILES IN imgFiles: ", imgFiles);
  //}, [imgFiles]);
  //useEffect(() => {
  //  console.log("UPDATED BASE 64 IMAGES: ", images64);
  //}, [images64]);
  //useEffect(() => {
  //  console.log("UPDATED BLOBS URLS: ", downloadUrls);
  //}, [downloadUrls]);
  //useEffect(() => {
  //  console.log("UPDATED IMAGE FILE NAMES: ", imgFileNames);
  //}, [imgFileNames]);
  //useEffect(() => {
  //  console.log("UPDATED DISPLAY IMAGES: ", displayImages);
  //}, [displayImages]);

  // Function to handle file selection
  const handleFileChange = (event: any) => {
    if (event.target.files == null || event.target.files.length === 0) {
      // Reset the image state if no file is selected or the dialog is closed
      setImages64([]);
      setImgFiles([]);
      return;
    }

    const selectedFiles = Array.from(event.target.files as FileList);
    console.log("SELECTED FILE CHANGED: ", selectedFiles);
    setImgFiles((prevFiles) => [...prevFiles, ...selectedFiles]);

    for (const file of selectedFiles) {
      // ADD FILE NAMES AS ANNOTATIONS USING imgFileNames.. DO NOT FORGET AS THIS IS IMPORTANT BRO
      console.log("FILE NAME OF : ", file.name);
      setImageFileNames((prevFileNames) => [...prevFileNames, file.name]);
      const url = URL.createObjectURL(file);
      setDisplayImages((prevState) => ({
        ...prevState,
        [imgIdx]: [...(prevState[imgIdx] || []), url],
      }));

      console.log(url);
      const reader = new FileReader();
      reader.readAsDataURL(file); // YOU NEED TO MAP MOST OF THIS IN AN ARRAY
      reader.onload = () => {
        if (typeof reader.result == "string") {
          setImages64((prevImages) => [...prevImages, reader.result]);
        }
      };
      reader.onerror = (error) => {
        console.log("error: " + error);
      };
    }
  };

  // Function to handle file deletion
  const handleDeleteFile = (index: any) => {
    console.log("INDEX TO REMOVE: ", index);
    const updatedFiles = [...imgFiles];
    updatedFiles.splice(index, 1);
    console.log("UPDATED FILES:", updatedFiles);
    setImgFiles(updatedFiles);

    // UPDATE DISPLAY IMAGES
    const updatedDisplay = displayImages[imgIdx];
    updatedDisplay.splice(index, 1);
    setDisplayImages((prevState) => ({
      ...prevState,
      [imgIdx]: updatedDisplay,
    }));

    // UPDATE FILE NAMES
    const updatedFileNames = imgFileNames;
    updatedFileNames.splice(index, 1);
    setImageFileNames(updatedFileNames);

    // UPDATE BASE 64
    const updatedBase64 = images64;
    updatedBase64.splice(index, 1);
    setImages64(updatedBase64);
  };
  // Needed for Downloading an Image
  const generateRandomFileName = () => {
    const timestamp = Date.now();
    const randomNumber = Math.floor(Math.random() * 1000000);
    return `image-${timestamp}-${randomNumber}`;
  };
  const handleDownload = async (
    e: React.MouseEvent<HTMLAnchorElement, MouseEvent>,
    url: string | URL | Request
  ) => {
    e.preventDefault();
    try {
      const response = await fetch(url, {
        method: "GET",
        headers: {},
      });
      const buffer = await response.arrayBuffer();
      const downloadFileName = generateRandomFileName();
      const blobUrl = window.URL.createObjectURL(new Blob([buffer]));
      const link = document.createElement("a");
      link.href = blobUrl;
      link.setAttribute("download", `${downloadFileName}.png`); // or any other extension
      document.body.appendChild(link);
      link.click();

      // Clean up
      link.remove();
      window.URL.revokeObjectURL(blobUrl);
    } catch (err) {
      console.error("Download failed:", err);
    }
  };
  const addSuggestion = (suggestion: string) => {
    // Combine suggestion with the current input value
    const combinedInput = `${input} \n[${suggestion.trim()}]`;
    // Create a synthetic event object with the value property
    const event = {
      target: { value: combinedInput },
    } as ChangeEvent<HTMLTextAreaElement>;
    // Update the input state with the combined value
    handleInputChange(event);
  };

  const handleInputPaste = (e: React.ClipboardEvent<HTMLTextAreaElement>) => {
    // Check if the event target is the correct element (optional)
    if (e.target instanceof HTMLTextAreaElement) {
      console.log("Pasting content detected");

      // Access pasted data
      const items = e.clipboardData?.items;
      if (items) {
        for (const item of items) {
          // console.logs pasted data
          if (item.type.startsWith("image/")) {
            const blob = item.getAsFile();
            if (blob) {
              const pastedImageName = generateRandomFileName();
              const pastedimageFile = new File(
                [blob],
                `pasted-${pastedImageName}.png`,
                { type: blob.type }
              );
              console.log("Pasted image File:", pastedimageFile);

              // Use the process from inputFileChange

              // add the pasted image file to the array of image files
              setImgFiles((prevFiles) => [...prevFiles, pastedimageFile]);

              // add the name of the pasted image to the array of image file names
              setImageFileNames((prevFileNames) => [
                ...prevFileNames,
                pastedimageFile.name,
              ]);
              const url = URL.createObjectURL(pastedimageFile);

              // add the temporary display url of the pasted image
              setDisplayImages((prevState) => ({
                ...prevState,
                [imgIdx]: [...(prevState[imgIdx] || []), url],
              }));

              // convert to base64
              const reader = new FileReader();
              reader.readAsDataURL(pastedimageFile);
              reader.onload = () => {
                if (typeof reader.result == "string") {
                  setImages64((prevImages) => [...prevImages, reader.result]);
                }
              };
              reader.onerror = (error) => {
                console.log("error: " + error);
              };
            }
          }
        }
      }
    }
  };

  // JSX ELEMENT:
  return (
    <div className="flex h-screen w-full">
      <SessionProvider>
        <SideBar />
      </SessionProvider>
      {isHistoryOpen && (
        <PersonaChatHistory
          refreshHistory={refreshHistory}
          mobileIsOpenHistory={mobileIsOpenHistory}
          setMobileIsOpenHistory={setMobileIsOpenHistory}
        />
      )}

      {/* Main Content */}

      <div className="flex flex-1 flex-col h-screen dark:bg-dark-mode dark:text-slate-100">
        <main className="relative overflow-auto pt-5 bg-slate-100 dark:bg-opacity-0 pb-0 h-full mob:pt-12 mob:pb-16">
          <PersonaCard
            persona={"ai"}
            setIsOpenHistory={setIsHistoryOpen}
            task={aiTask}
            logo={aiLogo}
            setMobileIsOpenHistory={setMobileIsOpenHistory}
          />

          <div className="pt-4 px-2 ps-4 pb-8 grid gap-6 max-w-5xl m-auto mob:pr-4">
            {messages.map((m, i) => {
              const isLastMessage: boolean = i === messages.length - 1;

              if (m.role === "user" && m.id != "firstprompt") {
                {
                  /* User message */
                }
                return (
                  <>
                    {
                      // If the output is an image (URL), display it
                      m.content.startsWith("https") ||
                      m.content.startsWith("blob:http") ? (
                        <div className="flex items-start gap-4 justify-end ">
                          <div className="grid gap-1.5 rounded-lg bg-primary p-3 px-4">
                            <Image
                              src={m.content}
                              alt={`Uploaded preview`}
                              style={{ maxWidth: "200px", height: "auto" }}
                            ></Image>
                            <a
                              href={m.content}
                              download
                              onClick={(e) => handleDownload(e, m.content)}
                            >
                              <svg
                                xmlns="http://www.w3.org/2000/svg"
                                fill="none"
                                viewBox="0 0 24 24"
                                stroke-width="1.5"
                                stroke="currentColor"

                                className="size-6"

                              >
                                <path
                                  stroke-linecap="round"
                                  stroke-linejoin="round"
                                  d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"
                                />
                              </svg>
                            </a>
                          </div>
                        </div>
                      ) : (
                        // Otherwise, assume the output is text and format it accordingly
                        <div
                          key={i}
                          className="flex items-start gap-4 justify-end"
                        >
                          <div className="grid gap-1.5 rounded-lg bg-primary p-3 px-4">
                            <p className="text-white">{m.content}</p>
                          </div>
                        </div>
                      )
                    }
                  </>
                );
              } else if (m.role == "assistant") {
                {
                  /* Chatbot message */
                }

                // if ((isLoading || isLoading2) && isLastMessage)
                //   return (
                //     <AgentChatLoading key={i} aiLogo={aiLogo} aiName={aiName} />
                //   );

                const isHovered: boolean = i === hoveredMessageIndex;
                return (
                  <div
                    key={i}
                    className="flex items-start gap-1"
                    onMouseEnter={() => setHoveredMessageIndex(i)}
                    onMouseLeave={() => setHoveredMessageIndex(null)}
                  >
                    {/** AI Logo */}
                    <div className="pt-4 mob:hidden">
                      <div className="h-[40px] w-[40px] rounded-full bg-slate-400 overflow-clip">
                        <Image
                          src={aiLogo ?? "/default_blue.png"}
                          alt="default chatbot icon"
                          width={100}
                          height={100}
                        />
                      </div>
                    </div>

                    <div className="relative grid gap-1.5 p-3 px-4 text-base">
                      <div className="flex items-center mob:mb-2">
                        <Image
                          src={aiLogo ?? "/default_blue.png"}
                          alt="default chatbot icon"
                          width={25}
                          height={25}
                          className="rounded-full mr-2 hidden mob:flex"
                        />
                        <h1 className="font-semibold">{aiName}</h1>
                      </div>
                      {
                        // If the output is an image (URL), display it
                        m.content.startsWith("https") ? (
                          <div>
                            <p>Here is your image:</p>
                            <img src={m.content} alt="Generated" />

                            <a href={m.data?.toString()}>
                              <svg
                                xmlns="http://www.w3.org/2000/svg"
                                fill="none"
                                viewBox="0 0 24 24"
                                stroke-width="1.5"
                                stroke="currentColor"
                                className="size-6"
                              >
                                <path
                                  stroke-linecap="round"
                                  stroke-linejoin="round"
                                  d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"
                                />
                              </svg>
                            </a>
                          </div>
                        ) : (
                          // Otherwise, assume the output is text and format it accordingly
                          // <pre
                          //   className={`${inter.className} text-wrap agent-response`}
                          // >
                          //   <Typewriter
                          //     options={{
                          //       strings: m.content,
                          //       autoStart: true,
                          //       delay: 5,
                          //       skipAddStyles: true,
                          //       cursorClassName: "TypeCursor",
                          //     }}
                          //   />
                          // </pre>
                          <div
                            dangerouslySetInnerHTML={{
                              __html: DOMPurify.sanitize(formatTextToHTML(m.content)) ,
                            }}
                          />
                        )
                      }

                      {(isLastMessage || isHovered) &&
                        !m.content.startsWith("https") && (
                          <div className="absolute z-10 bottom-[-15px] left-4 mt-1 flex gap-2">
                            <Button
                              variant="ghost"
                              size="iconSmall"
                              className="bg-none"
                              onClick={() =>
                                navigator.clipboard.writeText(m.content)
                              }
                            >
                              <CopyIcon />
                              <span className="sr-only">More</span>
                            </Button>

                            <Button
                              variant="ghost"
                              size="iconSmall"
                              className="bg-none"
                              onClick={() =>
                                handleChatRegenerate(
                                  messages,
                                  i,
                                  m.content,
                                  setIsLoading2,
                                  setMessages
                                )
                              }
                            >
                              <RegenerateIcon />
                              <span className="sr-only">More</span>
                            </Button>
                          </div>
                        )}
                    </div>
                  </div>
                );
              }
            })}
            {/* End to scroll automatically */}
            <div ref={endOfMessagesRef} />
          </div>
        </main>

        {/* INPUT */}
        <form
          onSubmit={promptSubmit}
          className="pb-[20px] bg-slate-100 dark:bg-opacity-0 px-5 max-h-96 flex-1 mob:fixed mob:bottom-0 mob:z-10 mob:p-0 mob:w-full"
        >
          {/* UPLOADED FILES LIST is DISPLAYED HERE */}
          <UploadedFiles files={imgFiles} onDelete={handleDeleteFile} />

          <div
            className={
              !isImageModel
                ? `rounded-lg max-w-5xl m-auto z-10 flex items-start  gap-2 border bg-white dark:bg-slate-700 dark:border-slate-500 px-4 h-auto sm:px-3 p-2`
                : `rounded-lg max-w-5xl m-auto z-10 flex mob:flex-col gap-2 border bg-white dark:bg-slate-700 dark:border-slate-500 px-4 h-auto sm:px-3 p-2`
            }
          >
            <div
              className={
                !isImageModel
                  ? `w-full flex items-start justify-between `
                  : `w-full flex flex-col h-auto gap-1 border rounded-md p-2 mob:flex-row`
              }
            >
              {/* Text Prompt input */}
              <Input
                placeholder={placeholder}
                value={input}
                className={
                  !isImageModel
                    ? `bg-transparent placeholder:text-base p-2 px-4 persona-selection-scrollbar h-auto mob:w-full` //text mode
                    : `bg-transparent px-1 pt-1 placeholder:text-base h-full persona-selection-scrollbar mob:w-full` //image mode
                }
                onChange={handleInputChange}
                onPaste={handleInputPaste}
                disabled={isLoading || isLoading2}
                onKeyDown={(e) => {
                  if (e.key === "Enter" && !e.shiftKey && input) {
                    // submit it
                    e.preventDefault(); // Prevents default form submission
                    promptSubmit(e); // Triggers form submission
                  } else {
                    if (isImageModel) {
                      handleTimeout(input, isImageModel);
                    }
                  }
                }}
              />
              {/* <input type="file" id="fileUpload" name="fileUpload" /> */}

              {/* Hide these buttons if Image mode */}
              {!isImageModel && (
                <>
                  {/* SUBMIT BUTTON */}
                  <Button
                    variant="default"
                    size="icon"
                    className="bg-primary order-last p-3"
                    disabled={isLoading || isLoading2 || !input}
                  >
                    <SendIcon />
                    <span className="sr-only">Send</span>
                  </Button>

                  <FileUploadComponent onFileChange={handleFileChange} />
                </>
              )}

              {/* Toggle between text and image generation */}
              <ToggleButton
                iconA={<TextIcon />}
                iconB={<ImageIcon />}
                className="order-first self-start"
                changeModel={handleModelChange}
              />

              {/* Suggestion Chips */}
              {isImageModel && (
                <SuggestionChips
                  suggestions={promptSuggestions}
                  suggestionClicked={addSuggestion}
                />
              )}
            </div>

            {/* Image model setting */}
            {isImageModel && (
              <div className="min-w-80 border rounded-lg h-auto flex flex-col p-3 gap-2">
                <div className="flex justify-between items-center">
                  <label
                    className="font-semibold text-slate-700 dark:text-slate-300"
                    htmlFor=""
                  >
                    Model
                  </label>

                  {/* Dropdown for model selection */}
                  <select
                    value={model}
                    onChange={(e) => {
                      setModel(e.target.value);
                      setQuantity(1);
                    }}
                    className="text-sm text-slate-600 py-1 px-2 border rounded-md bg-slate-50 "
                    disabled={
                      (model !== "dall-e-2" && model !== "dall-e-3") ||
                      isLoading ||
                      isLoading2
                    }
                  >
                    <option value="dall-e-2">DALL-E 2</option>
                    <option value="dall-e-3">DALL-E 3</option>
                  </select>
                </div>

                {/* Dropdown for image quality selection */}
                <div className="flex justify-between items-center ">
                  <label
                    className="font-semibold text-slate-700 dark:text-slate-300"
                    htmlFor=""
                  >
                    Quality{" "}
                    <sup className="font-normal text-slate-600 dark:text-slate-400">
                      DALL-E3
                    </sup>
                  </label>
                  <select
                    value={quality}
                    onChange={(e) => {
                      setQuality(e.target.value);
                    }}
                    className="text-sm text-slate-600 py-1 px-2 border rounded-md bg-slate-50 dark:text-slate-300"
                    disabled={model !== "dall-e-3" || isLoading || isLoading2}
                  >
                    <option value="standard">Standard</option>
                    <option value="hd">HD</option>
                  </select>
                </div>

                {/* Dropdown for image size selection */}
                <div className="flex justify-between items-center">
                  <label
                    className="font-semibold text-slate-700 dark:text-slate-300"
                    htmlFor=""
                  >
                    Size
                  </label>
                  <select
                    value={imgSize}
                    onChange={(e) => setImgSize(e.target.value)}
                    className="text-sm text-slate-600 py-1 px-2 border rounded-md bg-slate-50"
                    disabled={
                      (model !== "dall-e-2" && model !== "dall-e-3") ||
                      isLoading ||
                      isLoading2
                    }
                  >
                    <option value="256x256" disabled={model !== "dall-e-2"}>
                      256x256
                    </option>
                    <option value="512x512" disabled={model !== "dall-e-2"}>
                      512x512
                    </option>
                    <option value="1024x1024">1024x1024</option>
                    <option value="1792x1024" disabled={model !== "dall-e-3"}>
                      1792x1024
                    </option>
                    <option value="1024x1792" disabled={model !== "dall-e-3"}>
                      1024x1792
                    </option>
                  </select>
                </div>

                {/* Dropdown for image style selection */}
                <div className="flex justify-between items-center ">
                  <label
                    className="font-semibold text-slate-700 dark:text-slate-300"
                    htmlFor=""
                  >
                    Style{" "}
                    <sup className="font-normal text-slate-600 dark:text-slate-400">
                      DALL-E3
                    </sup>
                  </label>

                  <select
                    value={imgStyle}
                    onChange={(e) => setImgStyle(e.target.value)}
                    className="text-sm text-slate-600 py-1 px-2 border rounded-md bg-slate-50"
                    disabled={model !== "dall-e-3" || isLoading || isLoading2}
                  >
                    <option value="natural">Natural</option>
                    <option value="vivid">Vivid</option>
                  </select>
                </div>

                {/* Dropdown for image quantity selection */}
                <div className="flex justify-between items-center">
                  <label
                    className="font-semibold text-slate-700 dark:text-slate-300"
                    htmlFor=""
                  >
                    Quantity{" "}
                    <sup className="font-normal text-slate-600 dark:text-slate-400">
                      DALL-E2
                    </sup>
                  </label>

                  <select
                    value={quantity}
                    onChange={(e) => setQuantity(Number(e.target.value))}
                    className="text-sm text-slate-600 py-1 px-2 border rounded-md bg-slate-50"
                    disabled={model !== "dall-e-2" || isLoading || isLoading2}
                  >
                    {[...Array(10)].map((_, i) => (
                      <option key={i + 1} value={i + 1}>
                        {i + 1}
                      </option>
                    ))}
                  </select>
                </div>
                <button className="py-2 bg-primary text-white rounded-lg mt-2"
                 disabled={isLoading || isLoading2}
                >
                  Generate
                </button>
              </div>
            )}
          </div>

          <p className="mob:hidden text-sm text-center pt-3 text-slate-500 dark:text-slate-400">
            This AI chatbot is for informational purposes only and should not be
            considered professional advice.
          </p>
        </form>
      </div>

      {/* Previus Sidebar commented out by ken */}
      {/* <SideBar onPersonaChange={handlePersonaChange} /> */}
      {/* <SideBar chatHistory={chatHistory} /> */}
    </div>
  );
}

interface SuggestionChipsProps {
  suggestions?: string[];
  suggestionClicked: (role: string) => void;
}

const SuggestionChips: React.FC<SuggestionChipsProps> = ({
  suggestions = [],
  suggestionClicked,
}) => {
  return (
    <div className="w-full mt-auto flex gap-1 mob:hidden">
      {suggestions.map((s) => (
        <button
          onClick={(e) => {
            e.preventDefault();
            suggestionClicked(s);
          }}
          key={s}
          className="bg-slate-50 dark:bg-slate-700 dark:border-slate-500 dark:text-slate-300 border rounded-sm py-1 px-2 text-sm text-slate-500 hover:bg-slate-100 hover:text-slate-600 mob:hidden"
        >
          {s}
        </button>
      ))}

      {/* More button? */}
      {/** Commented For Now */}
      {/* <button
        onClick={(e) => {
          e.preventDefault();
        }}
        className="bg-slate-50 dark:bg-slate-700 dark:border-slate-500 dark:text-slate-300 border rounded-sm py-1 px-2 text-sm text-slate-500 hover:bg-slate-100 hover:text-slate-600"
      >
        ...
      </button> */}
    </div>
  );
};

// ICONS
function SendIcon() {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="1.5"
      stroke="white"
      className="size-5"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M6 12 3.269 3.125A59.769 59.769 0 0 1 21.485 12 59.768 59.768 0 0 1 3.27 20.875L5.999 12Zm0 0h7.5"
      />
    </svg>
  );
}
function PlusIcon() {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="1.5"
      stroke="#64748b"
      className="size-7"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M12 9v6m3-3H9m12 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
      />
    </svg>
  );
}
function CopyIcon() {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="1.5"
      stroke="#64748b"
      className="size-6"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"
      />
    </svg>
  );
}
function RegenerateIcon() {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="1.5"
      stroke="#64748b"
      className="size-6"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99"
      />
    </svg>
  );
}
function TextIcon() {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="1.5"
      stroke="currentColor"
      className="size-6"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z"
      />
    </svg>
  );
}

function ImageIcon() {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="1.5"
      stroke="currentColor"
      className="size-6"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="m2.25 15.75 5.159-5.159a2.25 2.25 0 0 1 3.182 0l5.159 5.159m-1.5-1.5 1.409-1.409a2.25 2.25 0 0 1 3.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 0 0 1.5-1.5V6a1.5 1.5 0 0 0-1.5-1.5H3.75A1.5 1.5 0 0 0 2.25 6v12a1.5 1.5 0 0 0 1.5 1.5Zm10.5-11.25h.008v.008h-.008V8.25Zm.375 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Z"
      />
    </svg>
  );
}

function LeftArrow() {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="1.5"
      stroke="#64748b"
      className="size-6"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M15.75 9V5.25A2.25 2.25 0 0 0 13.5 3h-6a2.25 2.25 0 0 0-2.25 2.25v13.5A2.25 2.25 0 0 0 7.5 21h6a2.25 2.25 0 0 0 2.25-2.25V15M12 9l-3 3m0 0 3 3m-3-3h12.75"
      />
    </svg>
  );
}
